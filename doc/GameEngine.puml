@startuml
'https://plantuml.com/class-diagram
' DEFINE THEME:
!define LIGHTBLUE
!includeurl https://raw.githubusercontent.com/Drakemor/RedDress-PlantUML/master/style.puml

namespace Engine {

    class Engine {
        - _eventRegister: EventCallBackRegister
        - _entityManager: EntityManager
        - _systemManager: SystemManager
        - _componentManager: ComponentManager
        - _sceneManager: SceneManager
    }
    note top : Engine API
   Event.EventCallBackRegister "1" -- "1" Engine

    entity Entity
    note top : size_t

    entity Signature
    note top : bitset<MAX_COMPONENT>

    enum EntityName {
        DEFAULT: 0
        EXAMPLE_ENTITY: 1
    }
    enum ClusterName {
        GLOBAL: 0
        GAME: 1
        HOME: 2
        SETTINGS: 3
        ROOM_LIST: 4
        ROOM_CREATE: 5
    }
    /'
        COMPONENTS
    '/
    namespace Component {
        class Component<ComponentType> {
            - {static} size_t type

            + constructor()
            + getType(): size_t
        }

        class AbstractSyncComponent<Model> {
            - bool modified

            + void notifyUpdate()
            + bool isUpdated()
            + Model serialise()
            + void override(Model &data)
        }
        Component <|-- AbstractSyncComponent
    }
    /'
        ENTITY MANAGER
    '/
    namespace Entity {
        class EntityManager {
            - _public: EntityRegister
            - _private: EntityRegister

            + constructor()
            + Entity createPrivate(ClusterName name = ClusterName::GLOBAL, EntityName name = EntityName::NO_NAME)
            + Entity createPublic(ClusterName name = ClusterName::GLOBAL, EntityName name = EntityName::NO_NAME)
            + void setAsPublic(Entity privateEntity, Entity publicId)
            + void remove(Entity entity)
            + void remove(EntityName name)
            + void remove(ClusterName name)
            + bool exist(Entity entity)
            + bool exist(EntityCluster cluster = ClusterName::GLOBAL, EntityName entity = EntityName::NO_NAME)
            + bool hasComponent<ComponentType>(Entity entity)
            + bool hasComponents<ComponentTypeList...>(Entity entity)
            + Entity getId(EntityName name)
            + size_t getClusterSize(ClusterName name)

            - void allocate(size_t size)
            - vector<Signature> getSignatureList()
            - const Signature getSignature(Entity entity)
        }
        class EntityRegister {
            - vector<Signature> _signatures
            - vector<EntityBlock> _bookedEntities
            - vector<Entity> _freeEntities
            - _startInterval: size_t
            - _endInterval: size_t

            + constructor(size_t endInterval, size_t startInterval = 0)
            + void allocate(size_t size)
            + vector<Signature> getEntitySignatures()
            + Signature getSignature(Entity entity)
            + Entity create()
            + void forceCreate(Entity entity)
            + void reserve(Entity entity)
            + void remove(Entity entity)
            + void remove(EntityName name)
            + void remove(ClusterName name)
            + bool isset(Entity entity)
            + Entity getId(EntityName name)
            + size_t getClusterSize(ClusterName name)
            + bool exist(EntityCluster cluster = ClusterName::GLOBAL, EntityName entity = EntityName::NO_NAME)
            + bool hasComponent<ComponentType>(Entity entity)
            + bool hasComponents<ComponentTypeList...>(Entity entity)
        }
        EntityRegister "2" -- "1" EntityManager
        class EntityBlock {
            + _entity: Entity
            + _name: EntityName
            + _cluster: EntityCluster
        }
        EntityBlock "0...*" -- "1" EntityRegister
    }
    /'
        COMPONENT MANAGER
    '/
    namespace Component {
        class ComponentManager {
            - array<IComponentTypeRegister> components

            + void register<ComponentType>()
            + ComponentType &get<ComponentType>(Entity entity)
            + tuple<ComponentTypeList...&> getList<ComponentTypeList...>(Entity entity)
            + void add<ComponentType, Args...>(Entity entity, Args...)
            + void remove<ComponentType>(Entity entity)
            + void remove<ComponentType>(EntityName name)
            + Entity getOwner<ComponentType>(ComponentType const& component)
            + tuple<ComponentTypeList...> zipper<ComponentTypeList...>()

            - ComponentTypeRegister<ComponentType> getRegister<ComponentType>()
            - checkType<ComponentType>()
            - checkTypeList<ComponentTypeList...>()
        }
        IComponentTypeRegister "0...*" -- "1" ComponentManager

        interface IComponentTypeRegister {
            void allocate(size_t size)
            void remove(Entity entity)
        }

        class ComponentTypeRegister<ComponentType> {
            - vector<ComponentType> _list
            - vector<Entity> _componentOwners
            - map<Entity, size_t> _entityToComponent
            - vector<Signature> &_entitySignatures

            + ComponentTypeRegister<ComponentType>(vector<Signature> &signatures)
            + void allocate(size_t)
            + ComponentType &get(Entity entity)
            + void add<Args...>(Entity entity, Args...)
            + void remove(Entity entity)
            + Entity getOwner(ComponentType &component)
            + vector<ComponentType> getComponents()
        }
        IComponentTypeRegister <|-- ComponentTypeRegister
    }

    /'
        SYSTEM MODULE
    '/
    namespace System {
        class SystemManager {
            - _list: vector<AbstractSystem>
            - _selected: vector<reference<AbstractSystem>>

            + register<SystemType, Args...>(Args...): SystemType &
            + unRegister<SystemType>(): void
            + select<SystemTypeList...>()
            + execCycle()
            + onEntityUpdated(entity: Entity, signature: Signature): void
            + onEntityRemoved(entity: Entity): void
            + getSystem<SystemType>(): SystemType &

            - checkType<SystemType>(): void
        }
        AbstractSystem "0...*" -- "1" SystemManager

        class AbstractSystem {
            - _type: type_index
            - _requiredComponents: Signature
            - _managedEntities: vector<Entity>
            - _entityToIndex: map<Entity, size_t>

            + getType(): type_index
            + {abstract} run(): void
            + setRequirements<ComponentTypeList...>(): void
            + onEntityUpdated(Entity entity, Signature signature): void
            + onManagedEntityRemoved(Entity entity): void
            + onManagedEntityAdded(Entity entity): void
            + onEntityRemoved(Entity entity): void
            + attachEntity(Entity entity): void
            + detachEntity(Entity entity): void
            # getManagedEntities(): vector<Entity>&
        }
    }
    /'
        SCENE MODULE
    '/
    namespace Scene {
        class SceneManager {
            - _list: vector<IScene>
            - _currentScene: IScene &
            - _nextScene: shared<IScene>
            - _previousScenes: stack<reference<IScene>>

            + run(): void
            + register<SceneType, Args...>(Args...): void
            + unregister<SceneType>(): void
            + select<SceneType>(closePrevious = true: bool): void
            + selectPrevious(): void
            + havePrevious(): bool
            + getSelected(): IScene &
            + flushSelection(): void
            + get<SceneType>(): IScene &

            # launchSystemCycle(): void
        }
        IScene "0...*" -- "1" SceneManager

        interface IScene {
            + void close()
            + void open()
            + void run()

            + size_t getType()
            + ClusterName getCluster()
            + bool isClosed()
        }

        class AbstractScene {
            - _closed: bool
            - _cluster: ClusterName
            - _type: type_index

            + constructor(type: type_index, name: ClusterName)
            + destructor()
            + {abstract} run(): void
            + {abstract} open(): void
            + close(): void

            + getCluster(): ClusterName
            + isClosed(): bool
            + getType(): type_index
        }
        IScene <|-- AbstractScene
    }
    /'
        EVENT MODULE
    '/
    namespace Event {

        class EventCallBack<EventType> {
            - _event: const &IEvent
            - _callback: & std::function<void(Args...)>

            + constructor(event: const &IEvent)
            + call<Args...>(args: Args...): void
            + operator==(event: const& IEvent): bool
        }
        note bottom : Représente une action en cas d'événement
        IEventCallBack <|-- EventCallBack

        interface IEventCallBack {
            + call<Args...>(args: Args...): void
            + operator==(event: const& IEvent): bool
        }

        class EventCallBackRegister {
            - _callbackList: unordered_map<IEvent, IEventCallBack>

            + register<EventType>(callback: CallbackType): void
            + dispatch<EventType>(Args...): void
            + dispatch(IEvent: event, Args...): void
            - checkType<EventType>(): void
        }
        EventCallBackRegister "1" -- "0..*" IEventCallBack
        EventCallBackRegister "1" -- "0..*" IEvent

        interface IEvent {
            + getType(): type_index
        }
        class Event<EventType> {
            - {static} type: type_index
            + getType(): type_index
        }
        note right : Représente un événement
        IEvent <|-- Event
    }
}

namespace Game {
    class GameHandler {
        - void onStartGame(const StartGameEvent &e)
    }

    namespace GameEvent {
        class StartGameEvent {}
        Event.Event <|-- StartGameEvent
    }
}

@enduml