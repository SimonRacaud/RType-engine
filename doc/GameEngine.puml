@startuml
'https://plantuml.com/class-diagram
' DEFINE THEME:
!define LIGHTBLUE
!includeurl https://raw.githubusercontent.com/Drakemor/RedDress-PlantUML/master/style.puml

namespace Engine {
    class EngineFactory {
        - {static} _singleton: unique<Engine> = null

        + {static} getInstance(): Engine&
    }
    note top: Singleton
    EngineFactory "1" -- "1" Engine

    class Engine {
        - _eventRegister: EventCallBackRegister
        - _entityManager: EntityManager
        - _systemManager: SystemManager
        - _componentManager: ComponentManager
        - _sceneManager: SceneManager
        - _loop: bool

        + exec(): void
        + quit(): void
    }
    note top : Engine API

    entity Entity
    note top : size_t

    entity Signature
    note top : bitset<MAX_COMPONENT>

    enum EntityName {
        DEFAULT: 0
        EXAMPLE_ENTITY: 1
    }
    enum ClusterName {
        GLOBAL: 0
        GAME: 1
        HOME: 2
        SETTINGS: 3
        ROOM_LIST: 4
        ROOM_CREATE: 5
    }
    /'
        COMPONENTS
    '/
    namespace Component {
        class Component<ComponentType> {
            - {static} type: type_index

            + constructor()
            + getType(): type_index
        }

        class AbstractSyncComponent<Model> {
            - _modified: bool

            + notifyUpdate(): void
            + isUpdated(): bool
            + {abstract} serialise(): Model
            + override(Model &data): void
        }
        Component <|-- AbstractSyncComponent
    }
    /'
        ENTITY MANAGER
    '/
    namespace Entity {
        class EntityManager {
            - _public: EntityRegister
            - _private: EntityRegister

            + constructor()
            + createPrivate(name = ClusterName::GLOBAL: ClusterName, name = EntityName::NO_NAME: EntityName): Entity
            + createPublic(name = ClusterName::GLOBAL: ClusterName, name = EntityName::NO_NAME: EntityName): Entity
            + setAsPublic(privateEntity: Entity, publicId: Entity): void
            + remove(entity: Entity): void
            + remove(name: EntityName): void
            + remove(name: ClusterName): void
            + exist(entity: Entity): bool
            + exist(cluster = ClusterName::GLOBAL: EntityCluster, entity = EntityName::NO_NAME: EntityName): bool
            + hasComponent<ComponentType>(entity: Entity): bool
            + hasComponents<ComponentTypeList...>(entity: Entity): bool
            + getId(name: EntityName): Entity
            + getClusterSize(name: ClusterName): size_t

            - allocate(size: size_t): void
            - getSignatureList(): vector<Signature>
            - getSignature(entity: Entity): const Signature
        }
        class EntityRegister {
            - _signatures: vector<Signature>
            - _bookedEntities: vector<EntityBlock>
            - _freeEntities: vector<Entity>
            - _startInterval: size_t
            - _endInterval: size_t

            + constructor(endInterval: size_t, startInterval = 0: size_t)
            + allocate(size: size_t): void
            + getEntitySignatures(): vector<Signature>
            + getSignature(entity: Entity): Signature
            + create(): Entity
            ' Reserve public id
            + createForce(entity: Entity): void
            + remove(entity: Entity): void
            + remove(name: EntityName): void
            + remove(name: ClusterName): void
            + isset(entity: Entity): bool
            + getId(name: EntityName): Entity
            + getClusterSize(name: ClusterName): size_t
            + exist(cluster = ClusterName::GLOBAL: EntityCluster, entity = EntityName::NO_NAME: EntityName): bool
            + hasComponent<ComponentType>(entity: Entity): bool
            + hasComponents<ComponentTypeList...>(entity: Entity): bool
        }
        EntityRegister "2" -- "1" EntityManager
        class EntityBlock {
            + _entity: Entity
            + _name: EntityName
            + _cluster: EntityCluster
        }
        EntityBlock "0...*" -- "1" EntityRegister
    }
    /'
        COMPONENT MANAGER
    '/
    namespace Component {
        class ComponentManager {
            - _components: array<IComponentTypeRegister>

            + register<ComponentType>(): void
            + get<ComponentType>(entity: Entity): ComponentType &
            + getList<ComponentTypeList...>(entity: Entity): tuple<ComponentTypeList...&>
            + add<ComponentType, Args...>(entity: Entity, Args...): void
            + remove<ComponentType>(entity: Entity): void
            + remove<ComponentType>(name: EntityName): void
            + getOwner<ComponentType>(component: ComponentType const&): Entity
            + zipper<ComponentTypeList...>(): tuple<ComponentTypeList...>

            - getRegister<ComponentType>(): ComponentTypeRegister<ComponentType>
            - checkType<ComponentType>(): void
            - checkTypeList<ComponentTypeList...>(): void
        }
        IComponentTypeRegister "0...*" -- "1" ComponentManager

        interface IComponentTypeRegister {
            allocate(size: size_t): void
            remove(entity: Entity): void
        }

        class ComponentTypeRegister<ComponentType> {
            - _list: vector<ComponentType>
            - _componentOwners: vector<Entity>
            - _entityToComponent: map<Entity, size_t>
            - _entitySignatures: vector<Signature>&

            + constructor<ComponentType>(signatures: vector<Signature>&)
            + allocate(size: size_t): void
            + get(entity: Entity): ComponentType &
            + add<Args...>(entity: Entity, Args...): void
            + remove(entity: Entity): void
            + getOwner(component: ComponentType &): Entity
            + getComponents(): vector<ComponentType> &
        }
        IComponentTypeRegister <|-- ComponentTypeRegister
    }

    /'
        SYSTEM MODULE
    '/
    namespace System {
        class SystemManager {
            - _list: vector<AbstractSystem>
            - _selected: vector<reference<AbstractSystem>>

            + register<SystemType, Args...>(Args...): SystemType &
            + unRegister<SystemType>(): void
            + select<SystemTypeList...>()
            + execCycle()
            + onEntityUpdated(entity: Entity, signature: Signature): void
            + onEntityRemoved(entity: Entity): void
            + getSystem<SystemType>(): SystemType &

            - checkType<SystemType>(): void
        }
        AbstractSystem "0...*" -- "1" SystemManager

        class AbstractSystem {
            - _type: type_index
            - _requiredComponents: Signature
            - _managedEntities: vector<Entity>
            - _entityToIndex: map<Entity, size_t>
            - _runningFrequency: chrono::time_point<chrono::steady_clock>
            - _priority: Priority

            + constructor(runningFrequency: chrono::time_point<chrono::steady_clock> = DEFAULT_FREQ, priority: Priority = MEDIUM)
            + getPriority(): Priority
            + getType(): type_index
            + {abstract} run(): void
            + setRequirements<ComponentTypeList...>(): void
            + onEntityUpdated(Entity entity, Signature signature): void
            + onManagedEntityRemoved(Entity entity): void
            + onManagedEntityAdded(Entity entity): void
            + onEntityRemoved(Entity entity): void
            + attachEntity(Entity entity): void
            + detachEntity(Entity entity): void
            # getManagedEntities(): vector<Entity>&
        }
    }
    /'
        SCENE MODULE
    '/
    namespace Scene {
        class SceneManager {
            - _list: vector<IScene>
            - _currentScene: IScene &
            - _nextScene: shared<IScene>
            - _previousScenes: stack<reference<IScene>>

            + run(): void
            + register<SceneType, Args...>(Args...): void
            + unregister<SceneType>(): void
            + select<SceneType>(closePrevious = true: bool): void
            + selectPrevious(): void
            + havePrevious(): bool
            + getSelected(): IScene &
            + flushSelection(): void
            + get<SceneType>(): IScene &

            # launchSystemCycle(): void
        }
        IScene "0...*" -- "1" SceneManager

        interface IScene {
            + close(): void
            + open(): void

            + getType(): type_index
            + getCluster(): ClusterName
            + isClosed(): bool
        }

        class AbstractScene {
            - _closed: bool
            - _cluster: ClusterName
            - _type: type_index

            + constructor(type: type_index, name: ClusterName)
            + destructor()
            + {abstract} open(): void
            + close(): void

            + getCluster(): ClusterName
            + isClosed(): bool
            + getType(): type_index
        }
        IScene <|-- AbstractScene
    }
    /'
        EVENT MODULE
    '/
    namespace Engine.Event {
        class EventCallBack<EventType> {
            - _callback: & std::function<void(EventType)>

            + constructor(callback: std::function<void(EventType *)> &)
            + call(const IEvent *e): void
            + operator==(event: const& IEvent): bool
        }
        note bottom : Représente une action en cas d'événement
        IEventCallBack <|-- EventCallBack

        interface IEventCallBack {
            + call(const IEvent *e): void
            + operator==(event: const& IEvent): bool
        }


        class EventCallBackRegister {
            - _callbackList: unordered_map<std::type_index, std::shared_ptr<IEventCallBack>>
            - _queue: queue<std::shared_ptr<IEvent>>

            + registerCallback<EventType>(callback: CallbackType): void
            + registerEvent<EventType>(Args...): void
            + execQueue(): void
            - checkType<EventType>(): void
        }
        EventCallBackRegister "1" -- "0..*" IEventCallBack
        EventCallBackRegister "1" -- "0..*" IEvent

        interface IEvent {
            + getType(): type_index
        }
        class AbstractEvent {
            - {static} type: type_index
            + getType(): type_index
        }
        note right : Représente un événement
        IEvent <|-- AbstractEvent
    }
    namespace Exception {
        class Basic {
            - _message: string

            + constructor(message: string const&)
            + what(): const char *
        }
        std::exception <|-- Basic

        class InvalidType
        class NotFound
        class InvalidParameter
        class FatalError
        class RuntimeError

        Basic <|-- RuntimeError
        Basic <|-- FatalError
        Basic <|-- InvalidParameter
        Basic <|-- InvalidType
        Basic <|-- NotFound
    }
}
namespace Game {
    class GameHandler {
        - onStartGame(e: const StartGameEvent&): void
    }

    namespace GameEvent {
        class StartGameEvent {
            constructor(example: Int)
        }
        Engine.Event.AbstractEvent <|-- StartGameEvent
    }
}

@enduml